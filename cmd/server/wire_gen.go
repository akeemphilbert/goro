// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package main

import (
	"github.com/akeemphilbert/goro/internal/conf"
	http2 "github.com/akeemphilbert/goro/internal/infrastructure/transport/http"
	"github.com/akeemphilbert/goro/internal/infrastructure/transport/http/handlers"
	"github.com/akeemphilbert/goro/internal/ldp/application"
	"github.com/akeemphilbert/goro/internal/ldp/infrastructure"
	"github.com/go-kratos/kratos/v2"
	"github.com/go-kratos/kratos/v2/log"
	"github.com/go-kratos/kratos/v2/transport/grpc"
	"github.com/go-kratos/kratos/v2/transport/http"
	"github.com/google/wire"
	"time"
)

import (
	_ "go.uber.org/automaxprocs"
)

// Injectors from wire.go:

// wireApp init kratos application.
func wireApp(server *conf.Server, logger log.Logger) (*kratos.App, func(), error) {
	http := server.HTTP
	healthHandler := handlers.NewHealthHandler(logger)
	requestResponseHandler := handlers.NewRequestResponseHandler(logger)
	streamingResourceRepository, err := infrastructure.NewOptimizedFileSystemRepositoryProvider()
	if err != nil {
		return nil, nil, err
	}
	rdfConverter := infrastructure.NewRDFConverter()
	db, err := infrastructure.DatabaseProvider()
	if err != nil {
		return nil, nil, err
	}
	gormEventStore, err := infrastructure.EventStoreProvider(db)
	if err != nil {
		return nil, nil, err
	}
	eventDispatcher, err := infrastructure.NewEventDispatcher()
	if err != nil {
		return nil, nil, err
	}
	v := infrastructure.NewUnitOfWorkFactory(gormEventStore, eventDispatcher)
	storageService, err := application.NewStorageServiceProvider(streamingResourceRepository, rdfConverter, v, eventDispatcher)
	if err != nil {
		return nil, nil, err
	}
	resourceHandler := handlers.NewResourceHandlerProvider(storageService, logger)
	container := server.Container
	containerRepository, err := infrastructure.NewFileSystemContainerRepositoryProvider(container)
	if err != nil {
		return nil, nil, err
	}
	containerRDFConverter := infrastructure.NewContainerRDFConverter()
	containerService, err := application.NewContainerServiceProvider(containerRepository, v, eventDispatcher, containerRDFConverter)
	if err != nil {
		return nil, nil, err
	}
	containerHandler := handlers.NewContainerHandlerProvider(containerService, storageService, logger)
	httpServer := NewHTTPServerProvider(http, logger, healthHandler, requestResponseHandler, resourceHandler, containerHandler)
	grpc := server.GRPC
	grpcServer := NewGRPCServer(grpc, logger)
	app, cleanup := newAppWithCleanup(logger, httpServer, grpcServer, server)
	return app, func() {
		cleanup()
	}, nil
}

// wire.go:

// newAppWithCleanup creates both the app and cleanup function
func newAppWithCleanup(logger log.Logger, hs *http.Server, gs *grpc.Server, config *conf.Server) (*kratos.App, func()) {
	app := newApp(logger, hs, gs, config)
	cleanup := func() {

	}
	return app, cleanup
}

// ProviderSet is the provider set for Wire dependency injection
var ProviderSet = wire.NewSet(handlers.NewHealthHandler, handlers.NewRequestResponseHandler, handlers.ProviderSet, application.ProviderSet, infrastructure.InfrastructureSet, NewGRPCServer,
	NewHTTPServerProvider, wire.FieldsOf(new(*conf.Server), "HTTP", "GRPC", "Container"),
)

// NewGRPCServer creates a new gRPC server
func NewGRPCServer(c *conf.GRPC, logger log.Logger) *grpc.Server {
	var opts = []grpc.ServerOption{grpc.Network(c.Network), grpc.Address(c.Addr)}
	if c.Timeout != 0 {
		opts = append(opts, grpc.Timeout(time.Duration(c.Timeout)))
	}

	srv := grpc.NewServer(opts...)
	return srv
}

// NewHTTPServerProvider creates an HTTP server with all handlers properly wired
func NewHTTPServerProvider(
	c *conf.HTTP,
	logger log.Logger,
	healthHandler *handlers.HealthHandler,
	requestResponseHandler *handlers.RequestResponseHandler,
	resourceHandler *handlers.ResourceHandler,
	containerHandler *handlers.ContainerHandler,
) *http.Server {
	return http2.NewHTTPServer(c, logger, healthHandler, requestResponseHandler, resourceHandler, containerHandler)
}

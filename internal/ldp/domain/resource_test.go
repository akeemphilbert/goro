package domain

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestNewResource(t *testing.T) {
	resource := NewResource("test-resource-1", "text/turtle", []byte("@prefix ex: <http://example.org/> ."))

	assert.NotNil(t, resource)
	assert.Equal(t, "test-resource-1", resource.ID())
	assert.Equal(t, "text/turtle", resource.ContentType)
	assert.Equal(t, []byte("@prefix ex: <http://example.org/> ."), resource.Data)
	assert.NotNil(t, resource.Metadata)

	// Check that a created event was emitted
	events := resource.UncommittedEvents()
	assert.Len(t, events, 1)
	assert.Equal(t, EventTypeResourceCreated, events[0].(*EntityEvent).Type)
}

func TestNewResource_AutoGeneratedID(t *testing.T) {
	resource := NewResource("", "application/ld+json", []byte(`{"@context": "http://example.org"}`))

	assert.NotNil(t, resource)
	assert.NotEmpty(t, resource.ID())
	assert.Equal(t, "application/ld+json", resource.ContentType)
	assert.Equal(t, []byte(`{"@context": "http://example.org"}`), resource.Data)
}

func TestResource_FromJSONLD_Valid(t *testing.T) {
	resource := NewResource("test-id", "text/plain", []byte("initial"))
	initialEvents := len(resource.UncommittedEvents())

	data := []byte(`{
		"@context": "http://schema.org",
		"@type": "Person",
		"name": "John Doe"
	}`)

	result := resource.FromJSONLD(data)

	assert.Equal(t, resource, result)
	assert.True(t, resource.IsValid())
	assert.Equal(t, "application/ld+json", resource.ContentType)
	assert.Equal(t, data, resource.Data)
	assert.Equal(t, "application/ld+json", resource.Metadata["originalFormat"])
	assert.NotNil(t, resource.Metadata["updatedAt"])

	// Check that an update event was emitted
	events := resource.UncommittedEvents()
	assert.Len(t, events, initialEvents+1)
	assert.Equal(t, EventTypeResourceUpdated, events[len(events)-1].(*EntityEvent).Type)
}

func TestResource_FromJSONLD_Invalid(t *testing.T) {
	resource := NewResource("test-id", "text/plain", []byte("initial"))

	// Test invalid JSON
	result := resource.FromJSONLD([]byte(`{"invalid": json}`))
	assert.Equal(t, resource, result)
	assert.False(t, resource.IsValid())
	errors := resource.Errors()
	assert.Len(t, errors, 1)
	assert.Contains(t, errors[0].Error(), "invalid JSON-LD format")

	// Reset errors for next test
	resource.Reset()

	// Test JSON without @context
	result = resource.FromJSONLD([]byte(`{"@type": "Person", "name": "John Doe"}`))
	assert.Equal(t, resource, result)
	assert.False(t, resource.IsValid())
	errors = resource.Errors()
	assert.Len(t, errors, 1)
	assert.Contains(t, errors[0].Error(), "JSON-LD data must contain @context")
}

func TestResource_FromRDF_Valid(t *testing.T) {
	resource := NewResource("test-id", "text/plain", []byte("initial"))
	initialEvents := len(resource.UncommittedEvents())

	data := []byte(`<rdf:RDF><person>John</person></rdf:RDF>`)

	result := resource.FromRDF(data)

	assert.Equal(t, resource, result)
	assert.True(t, resource.IsValid())
	assert.Equal(t, "application/rdf+xml", resource.ContentType)
	assert.Equal(t, data, resource.Data)
	assert.Equal(t, "application/rdf+xml", resource.Metadata["originalFormat"])
	assert.NotNil(t, resource.Metadata["updatedAt"])

	// Check that an update event was emitted
	events := resource.UncommittedEvents()
	assert.Len(t, events, initialEvents+1)
	assert.Equal(t, EventTypeResourceUpdated, events[len(events)-1].(*EntityEvent).Type)
}

func TestResource_FromRDF_Empty(t *testing.T) {
	resource := NewResource("test-id", "text/plain", []byte("initial"))

	result := resource.FromRDF([]byte(``))
	assert.Equal(t, resource, result)
	assert.False(t, resource.IsValid())
	errors := resource.Errors()
	assert.Len(t, errors, 1)
	assert.Contains(t, errors[0].Error(), "RDF/XML data cannot be empty")
}

func TestResource_FromTurtle_Valid(t *testing.T) {
	resource := NewResource("test-id", "text/plain", []byte("initial"))
	initialEvents := len(resource.UncommittedEvents())

	data := []byte(`@prefix ex: <http://example.org/> .
		ex:person ex:name "John Doe" .`)

	result := resource.FromTurtle(data)

	assert.Equal(t, resource, result)
	assert.True(t, resource.IsValid())
	assert.Equal(t, "text/turtle", resource.ContentType)
	assert.Equal(t, data, resource.Data)
	assert.Equal(t, "text/turtle", resource.Metadata["originalFormat"])
	assert.NotNil(t, resource.Metadata["updatedAt"])

	// Check that an update event was emitted
	events := resource.UncommittedEvents()
	assert.Len(t, events, initialEvents+1)
	assert.Equal(t, EventTypeResourceUpdated, events[len(events)-1].(*EntityEvent).Type)
}

func TestResource_FromTurtle_Empty(t *testing.T) {
	resource := NewResource("test-id", "text/plain", []byte("initial"))

	result := resource.FromTurtle([]byte(``))
	assert.Equal(t, resource, result)
	assert.False(t, resource.IsValid())
	errors := resource.Errors()
	assert.Len(t, errors, 1)
	assert.Contains(t, errors[0].Error(), "Turtle data cannot be empty")
}

func TestResource_FromXML_Alias(t *testing.T) {
	resource := NewResource("test-id", "text/plain", []byte("initial"))
	data := []byte(`<rdf:RDF><person>John</person></rdf:RDF>`)

	result := resource.FromXML(data)

	assert.Equal(t, resource, result)
	assert.True(t, resource.IsValid())
	assert.Equal(t, "application/rdf+xml", resource.ContentType)
	assert.Equal(t, data, resource.Data)
}

func TestResource_ToFormat(t *testing.T) {
	// Test same format return
	resource := NewResource("test-id", "application/ld+json", []byte(`{"@context": "http://schema.org"}`))

	result, err := resource.ToFormat("application/ld+json")
	assert.NoError(t, err)
	assert.Equal(t, resource.Data, result)

	// Test unsupported format
	_, err = resource.ToFormat("application/n-triples")
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "unsupported format")

	// Test format conversion not implemented
	_, err = resource.ToFormat("text/turtle")
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "format conversion from application/ld+json to text/turtle not yet implemented")
}

func TestResource_Update(t *testing.T) {
	resource := NewResource("test-id", "text/plain", []byte("initial"))
	initialEvents := len(resource.UncommittedEvents())

	newData := []byte("updated content")
	newContentType := "text/turtle"

	resource.Update(newData, newContentType)

	assert.Equal(t, newData, resource.Data)
	assert.Equal(t, newContentType, resource.ContentType)
	assert.NotNil(t, resource.Metadata["updatedAt"])

	// Check that an update event was emitted
	events := resource.UncommittedEvents()
	assert.Len(t, events, initialEvents+1)
	assert.Equal(t, EventTypeResourceUpdated, events[len(events)-1].(*EntityEvent).Type)
}

func TestResource_Delete(t *testing.T) {
	resource := NewResource("test-id", "text/plain", []byte("content"))
	initialEvents := len(resource.UncommittedEvents())

	resource.Delete()

	// Check that a delete event was emitted
	events := resource.UncommittedEvents()
	assert.Len(t, events, initialEvents+1)
	assert.Equal(t, EventTypeResourceDeleted, events[len(events)-1].(*EntityEvent).Type)
}

func TestResource_Getters(t *testing.T) {
	data := []byte("test content")
	contentType := "text/turtle"
	resource := NewResource("test-id", contentType, data)
	resource.SetMetadata("key1", "value1")

	assert.Equal(t, len(data), resource.GetSize())
	assert.Equal(t, contentType, resource.GetContentType())
	assert.Equal(t, data, resource.GetData())

	metadata := resource.GetMetadata()
	assert.Equal(t, "value1", metadata["key1"])
}

func TestResource_ErrorHandling(t *testing.T) {
	resource := NewResource("test-id", "text/plain", []byte("content"))

	// Test multiple errors accumulation
	resource.FromJSONLD([]byte(`invalid json`))
	resource.FromRDF([]byte(``))

	assert.False(t, resource.IsValid())
	errors := resource.Errors()
	assert.Len(t, errors, 2)
	assert.Contains(t, errors[0].Error(), "invalid JSON-LD format")
	assert.Contains(t, errors[1].Error(), "RDF/XML data cannot be empty")

	// Test error reset
	resource.Reset()
	assert.True(t, resource.IsValid())
	assert.Len(t, resource.Errors(), 0)
}

func TestResource_EventIntegration(t *testing.T) {
	// Test that all operations properly emit events
	resource := NewResource("test-id", "text/plain", []byte("initial"))

	// Should have 1 event (created)
	assert.Len(t, resource.UncommittedEvents(), 1)
	assert.Equal(t, EventTypeResourceCreated, resource.UncommittedEvents()[0].(*EntityEvent).Type)

	// Update via FromJSONLD
	resource.FromJSONLD([]byte(`{"@context": "http://schema.org"}`))
	assert.True(t, resource.IsValid())

	// Should have 2 events (created + updated)
	assert.Len(t, resource.UncommittedEvents(), 2)
	assert.Equal(t, EventTypeResourceUpdated, resource.UncommittedEvents()[1].(*EntityEvent).Type)

	// Update via Update method
	resource.Update([]byte("new content"), "text/turtle")

	// Should have 3 events (created + updated + updated)
	assert.Len(t, resource.UncommittedEvents(), 3)
	assert.Equal(t, EventTypeResourceUpdated, resource.UncommittedEvents()[2].(*EntityEvent).Type)

	// Delete
	resource.Delete()

	// Should have 4 events (created + updated + updated + deleted)
	assert.Len(t, resource.UncommittedEvents(), 4)
	assert.Equal(t, EventTypeResourceDeleted, resource.UncommittedEvents()[3].(*EntityEvent).Type)
}
